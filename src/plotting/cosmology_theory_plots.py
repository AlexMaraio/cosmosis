#!/usr/bin/env python

import matplotlib
matplotlib.use("Agg")
# We have to import matplotliv first so we can set the output
# before we load pylab
# This bit means it is not a great idea to import this script
# elsewhere

import pylab
import os
import argparse
import numpy as np


#Set up the command line arguments
parser = argparse.ArgumentParser(description="""
This script makes some standard plots based on a directory
of CosomoSIS output for a single set of cosmological parameters,
as generated by the "test" sampler in CosmoSIS.  Have a look at
the first demo we have for an example.

You need to supply at least the name of the directory where
CosmoSIS data was saved.
""")

parser.add_argument("dirname", help="A directory of cosmology data as produced by the 'test' sampler")
parser.add_argument("-o", "--output_dir", default=".", help="The directory in which to put the plots")
parser.add_argument("-p", "--prefix", default="", help="A filename prefix for all the plots")
parser.add_argument("-t", "--type", default="png", help="Image file type suffix")


#Okay, here is the structure of this script.
#We have a base Plot class which handles finding 
#the data files, working out filenames, and saving plots
# The subclasses are then in charge of the plot contents.

#The Plot classes also registers its subclasses so that 
#there is less plumbing to do when adding a new plot
plot_list = []
class Plot(object):
	#Subclasses should override this to specify the base
	#part of their filename
	filename = "error"

	# This bit does the auto-registering
	# It is some magic python
	class __metaclass__(type):
		def __init__(cls, name, b, d):
			type.__init__(cls, name, b, d)
			# The base classes should not be plotted themselves
			if name in ["Plot", "DistancePlot", "CMBSpectrumPlot"]:
				return
			#But otherwise we record it in our list
			plot_list.append(cls)

	def __init__(self, dirname, outdir, prefix, suffix):
		#Set up the plotting figure
		self.figure = pylab.figure()
		#Can do prefixes if we want to all the filenames
		if prefix:
			prefix += "_"
		#We have an output directory, a prefix, base filename (which is overridden by subclasses)
		#And a suffix (file type)
		self.filename = "{0}/{1}{2}.{3}".format(outdir, prefix, self.filename, suffix)
		#All the data will be in subclasses of this
		self.dirname = dirname

	def load_file(self, section, name):
		"Load a data file from the directory of saved theory data"
		#Find the filename and load it
		filename = "{0}/{1}/{2}.txt".format(self.dirname, section, name)
		return np.loadtxt(filename)

	#Handy little method for trying to numeric-ify a value
	@staticmethod
	def try_numeric(value):
		try:
			return float(value)
		except:
			pass
		try:
			return int(value)
		except:
			pass
		return value

	# The scalar parameters in the DataBlock are saved to a
	# file called values.txt for each section.
	# This file loads that values file into a dictionary
	def load_values(self, section):
		filename = "{0}/{1}/values.txt".format(self.dirname, section)
		values = {}
		for line in open(filename):
			line=line.strip()
			if not line:
				continue
			name, value = line.split('=')
			values[name.strip()] = self.try_numeric(value.strip())
		return values

	#Base method - subclasses should call this super method
	#and then override to supply their own plot content
	def plot(self):
		pylab.figure(self.figure.number)

	#Need not be over-ridden
	def save(self):
		pylab.figure(self.figure.number)
		print "Saving ", self.filename
		pylab.savefig(self.filename)

	#Need not be overridden. Called by the main function
	@classmethod
	def make(cls, dirname, outdir, prefix, suffix):
		p = cls(dirname, outdir, prefix, suffix)
		p.plot()
		p.save()

class DistancePlot(Plot):
	"Subclasses of this do distance plots as a function of z"
	scaling=1.0
	def plot(self):
		super(DistancePlot, self).plot()
		z = self.load_file("distances", "z")
		d = self.load_file("distances", self.distance)
		pylab.plot(z, d*self.scaling)
		pylab.grid()
		pylab.xlabel("Redshift z")
		pylab.ylabel(self.name)

class AngularDiameterDistancePlot(DistancePlot):
	distance = "d_a"
	filename = "angular_distance"
	name = "Angular Diameter Distance D_A / Mpc"

class LuminosityDistancePlot(DistancePlot):
	distance = "d_l"
	filename = "luminosity_distance"
	name = "Luminosity Distance D_L / Mpc"

class ComovingDistancePlot(DistancePlot):
	distance = "d_m"
	filename = "comoving_distance"
	name = "Comoving Distance D_L / Mpc"

class HubblePlot(DistancePlot):
	distance = "h"
	filename = "hubble"
	name = "Hubble Parameter H(z) / (km/s/Mpc)"
	scaling = 2.99792458e+05

class DistanceModulusPlot(DistancePlot):
	distance = "mu"
	filename = "distance_modulus"
	name = "Distance Modulus mu"

class CMBSpectrumPlot(Plot):
	"The four different C_ell plots are subclasses of this"
	def plot(self):
		super(CMBSpectrumPlot, self).plot()
		ell = self.load_file("cmb_cl", "ell")
		c_ell = self.load_file("cmb_cl", self.name)
		pylab.plot(ell, c_ell)
		pylab.grid()
		pylab.xlabel("ell")
		pylab.ylabel("C_ell {0} / uK^2".format(self.name.upper()))

class TTPlot(CMBSpectrumPlot):
	name = filename = "tt"

class EEPlot(CMBSpectrumPlot):
	name = filename = "ee"

class TEPlot(CMBSpectrumPlot):
	name = filename = "te"

class BBPlot(CMBSpectrumPlot):
	name = filename = "bb"

class GrandPlot(Plot):
	"Grand CMB plot with all four spectra"
	filename = "grand"
	def plot(self):
		super(GrandPlot, self).plot()
		ell = self.load_file("cmb_cl", "ell")
		for name in ['tt', 'ee', 'te', 'bb']:
			c_ell = self.load_file("cmb_cl", name)
			pylab.loglog(ell, abs(c_ell), label=name.upper())
		pylab.legend()
		pylab.grid()
		pylab.xlabel("ell")
		pylab.ylabel("C_ell Spectra / uK^2")

class MatterPowerPlot(Plot):
	"Matter power spectrum, maybe including non-linear plot too if available"
	filename = "matter_power"
	def plot_section(self, section, label):
		kh = self.load_file(section, "k_h")
		z = self.load_file(section, "z")
		p = self.load_file(section, "p_k")
		values = self.load_values(section)
		nk = values['nk']
		nz = values['nz']
		kh = kh.reshape((nk, nz))
		z  = z.reshape((nk, nz))
		p  = p.reshape((nk, nz))
		z0 = (z==0)
		pylab.loglog(kh[z0], p[z0], label=label)

	def plot(self):
		super(MatterPowerPlot, self).plot()
		self.plot_section("matter_power_lin", "Linear")
		if os.path.exists("{0}/matter_power_nl".format(self.dirname)):
			self.plot_section("matter_power_nl", "Non-Linear")
		pylab.xlabel("k / (Mpc/h)")
		pylab.ylabel("P(k) / (h^1 Mpc)^3")
		pylab.grid()
		pylab.legend()


def main(args):
	for cls in plot_list:
		try:
			cls.make(args.dirname, args.output_dir, args.prefix, args.type)
		except IOError:
			print "Could not make plot ", cls.filename


if __name__ == '__main__':
	args = parser.parse_args()
	main(args)