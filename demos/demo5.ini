[runtime]
; The emcee sampler, which uses the Goodman & Weare algorithm.
sampler = emcee

; Right now only the emcee sampler supports this feature:
; resuming a chain directly where it left off.
resume = T

[emcee]
; The emcee sampler uses the concept of walkers, a collection of live
; points.  Sampling is done along lines that connect pairs of walkers.
; The number of walkers must be at least 2*nparam + 1, but in general more
; than that usually works better.
walkers = 64
; This many samples is overkill, just to make the plots look a lot nicer.
samples = 400
; This is the interval at which convergence diagnostics are performed.
nsteps = 10

[zeus]
walkers = 32
samples = 100
nsteps = 10

; Alternatively you can switch to a metropolis sampler
[metropolis]
samples = 100000
cobaya = T
; do 200 samples before starting tuning
tuning_grace = 200
; re-tune every 200 samples
tuning_frequency = 200
; stop tuning after 1600 samples
tuning_end = 1600
; output every 100 samples
nsteps = 100
; declare convergence at R=1.03
; want to go lower for publishable chains
; this only operates when using multiple chains under MPI
Rconverge = 0.03
; If available use a proposal matrix to speed things up
; covmat = demos/demo5.cov
; use dragging in cobaya when fast/slow available.
; You also need to add fast_slow=T and first_fast_module=jla in 
; the pipeline section to enable this.
; This doesn't help this likelihood at all, because the fast parameters
; are not actually much faster than the slow ones.  In other likelihoods
; it can make a big difference.
; drag = 10
; If you want to watch the tuning process and check it is working
; you can switch this on, but remember to exclude those samples
; when post-processing.
; save_during_tuning=T


[output]
filename = output/demo5.txt
format = text
verbosity= debug

; If privacy is False then the header
; output of the chain will contain the username and hostname where the
; chain was run.  The default is privacy=T, in which case no such header will
; be included.
privacy = F


[pipeline]
; We use two likelihoods, the JLA (for high redshift) and Riess 2011 to
; anchor H0, which is otherwise degenerate with the nuisance parameter M.
modules = consistency camb jla riess11
values = demos/values5.ini
extra_output =
likelihoods = jla riess
; first_fast_module = jla
; fast_slow = T
quiet=T
debug=F
timing=F


; To use the maxlike sampler instead you can set sampler=maxlike at the
; top.
[maxlike]
; The values file we use in this example was created just like the one we
; made in demo4, by setting sampler = maxlike above, so that these
; settings were used:
output_ini = demos/values5a.ini
; A covariance can only be output by some optimization methods (those that
; find an approximation to it numerically).
output_covmat = new.cov
tolerance = 1e-6
max_posterior = F

; The BFGS method seems to find it a bit harder to actually locate the
; peak, but once it's there it provides you with covariance matrix
; estimate.
;method = Nelder-Mead
;method = BFGS

; Any minimizer available in scipy can be specified here - they are:
; Nelder-Mead
; Powell
; CG
; BFGS
; Newton-CG
; L-BFGS-B
; TNC
; COBYLA
; SLSQP
; dogleg
; trust-ncg



[camb]
; For background-only data we do not need a full Boltzmann evaluation,
; just D(z), etc.  Setting mode=background means we get this.
file = cosmosis-standard-library/boltzmann/camb/camb.so
mode=background
feedback=0

[jla]
; JLA needs quite a lot of parameters telling it where data files are ...
file = cosmosis-standard-library/supernovae/jla_v3/jla.so
data_dir = $COSMOSIS_SRC_DIR/cosmosis-standard-library/supernovae/jla_v3/data
data_file = jla_lcparams.txt
scriptmcut = 10.0
mag_covmat_file = jla_v0_covmatrix.dat
stretch_covmat_file = jla_va_covmatrix.dat
colour_covmat_file = jla_vb_covmatrix.dat
mag_stretch_covmat_file = jla_v0a_covmatrix.dat
mag_colour_covmat_file = jla_v0b_covmatrix.dat
stretch_colour_covmat_file = jla_vab_covmatrix.dat

; The Riess 11 likelihood anchors H0 for us.
[riess11]
file = cosmosis-standard-library/likelihood/riess11/riess11.py

; The consistency module translates between our chosen parameterization
; and any other that modules in the pipeline may want (e.g. camb).
[consistency]
file = cosmosis-standard-library/utility/consistency/consistency_interface.py
